# Devmatch The Graph Workshop

## Checkpoint One

### NFT Tracker Subgraph

This subgraph indexes `Mint` and `Transfer` events from Artblock's [ERC-721 contract](https://etherscan.io/address/0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270) deployed on **Ethereum mainnet**. It stores NFT ownership and token data, which can then be queried or enriched using **The Graph Token API**.

#### ðŸš€ Prerequisites

Make sure you have the following installed:

- Node.js v18+
- `yarn` package manager
- [The Graph CLI](https://thegraph.com/docs/en/developing/quick-start/#installing-the-graph-cli)

```bash
yarn global @graphprotocol/graph-cli
```

#### 1. Initialize the Subgraph

```bash
graph init \
  --from-contract 0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270 \
  --network mainnet \
  --index-events \
  nft-tracker-subgraph
```

**What Each Flag Means**
| Flag | Meaning |
| --- | --- |
| `--from-contract` | Tells The Graph CLI to auto-fetch the contract ABI and scaffold the subgraph around it. Saves you time. |
| `--network` | Specifies which Ethereum network to use. Must match the chain the contract is on. |
| `--index-events` | Automatically detects all events from the ABI and creates stubs in `subgraph.yaml` and `mapping.ts`. Youâ€™ll edit these later. |
| `nft-tracker-subgraph` | Your local folder name AND the internal project name for the CLI. |

Then, press `Enter` on subsequent inputs to use default values. Your CLI should look like this:
![Subgraph Initialization](/readme-images/subgraph-initialization.png)

Then, go into the folder:

```bash
cd nft-tracker-subgraph
```

#### Step 2: Update `schema.graphql`

Replace contents of `schema.graphql` with:

```graphql
type NFT @entity {
  id: ID!
  contract: Bytes!
  owner: Bytes!
  tokenId: BigInt!
}
```

The schema defines what data will be saved in the subgraphâ€™s database.
Each NFT record represents a single token.

- `id`: Unique identifier for the entity (we use `tokenId` as string).
- `contract`: Address of the NFT contract.
- `owner`: Who currently owns the NFT.
- `tokenId`: The unique number of the NFT (on-chain).

Lastly, input the following into the CLI to generate TypeScript bindings from your schema and ABI, so you can type-check mappings.

```bash
graph codegen
```

#### Step 3. Write the mappings

Edit `src/mapping.ts` to contain:

```typescript
import {
  Transfer as TransferEvent,
  Mint as MintEvent,
} from '../generated/GenArt721Core/GenArt721Core';
import { NFT } from '../generated/schema';

export function handleMint(event: MintEvent): void {
  let entity = new NFT(event.params._tokenId.toString());
  entity.owner = event.params._to;
  entity.tokenId = event.params._tokenId;
  entity.contract = event.address;
  entity.save();
}
export function handleTransfer(event: TransferEvent): void {
  // Retrieve NFT entity by ID
  let entity = NFT.load(event.params.tokenId.toString());

  if (!entity) {
    entity = new NFT(event.params.tokenId.toString());
  }

  entity.owner = event.params.to;
  entity.contract = event.address;
  entity.tokenId = event.params.tokenId;

  entity.save();
}
```

These handlers define how to convert blockchain events into structured data.

- handleMint: Creates a new NFT record.
- handleTransfer: Updates ownership or creates the record if itâ€™s missing (edge case).

#### Step 4. Update `subgraph.yaml`

Edit your `subgraph.yaml` to ensure it reflects your actual schema and mappings.

**What Changed?**

- **Replaced** the default `entities` list with just NFT to match our `schema.graphql`.

```yaml
entities:
  - NFT
```

- **Deleted** unused event handlers:

```yaml
- event: Approval(indexed address,indexed address,indexed uint256)
  handler: handleApproval

- event: ApprovalForAll(indexed address,indexed address,bool)
  handler: handleApprovalForAll
```

> [!NOTE]
> These were generated by `--index-events` but arenâ€™t handled in our `mapping.ts`, so we removed them to keep the project clean and avoid build warnings.

**Final YAML File**

```yaml
specVersion: 1.2.0
indexerHints:
  prune: auto
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: GenArt721Core
    network: mainnet
    source:
      address: '0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270'
      abi: GenArt721Core
      startBlock: 11437151
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.9
      language: wasm/assemblyscript
      entities:
        - NFT
      abis:
        - name: GenArt721Core
          file: ./abis/GenArt721Core.json
      eventHandlers:
        - event: Mint(indexed address,indexed uint256,indexed uint256)
          handler: handleMint
        - event: Transfer(indexed address,indexed address,indexed uint256)
          handler: handleTransfer
      file: ./src/gen-art-721-core.ts
```

#### Step 5. Generate and Build

```bash
graph codegen
graph build
```

- `graph codegen`: Generates TypeScript bindings from your schema and ABI, so you can type-check mappings.
- `graph build`: Compiles everything into WebAssembly so The Graph node can run it.

#### Step 6. Create a Subgraph in Subgraph Studio

Go to [Subgraph Studio](https://thegraph.com/studio/) and connect your wallet.

Subgraph Studio lets you create, manage, deploy, and publish subgraphs, as well as create and manage API keys.

Click "Create a Subgraph". It is recommended to name the subgraph in Title Case: "Subgraph Name Chain Name".

In our case, we can name it **"nft-tracker-ethereum"**

#### Step 7. Deploy the Subgraph

When you **deploy** a subgraph, you push it to [Subgraph Studio](https://thegraph.com/studio/), where you can test, stage and review it.

1. **Authenticate**

```bash
graph auth <DEPLOY_KEY>
```

Authenticate and deploy your subgraph. The deploy key can be found on the subgraph's page in Subgraph Studio.

![Deploy key](/readme-images/deploy-key.png)

2. **Deploy**

```
graph deploy nft-tracker-ethereum
```

The CLI will ask for a version label. It's strongly recommended to use [semantic versioning](https://semver.org/), e.g. `0.0.1`.

### 7. Review your subgraph

If youâ€™d like to test your subgraph, you can use run a sample query in the playground:

```graphql
{
  nfts(first: 10) {
    id
    tokenId
    owner
    contract
  }
}
```

## Checkpoint 2: Calling Subgraph From Next.js (Frontend)

This step walks you through setting up a Next.js app, installing dependencies, organizing subgraph query code, and rendering NFT responses from your subgraph using a simple page.

### 1. Create a New Next.js App

In the root folder, input the following command:

```bash
npx create-next-app@latest nft-subgraph-frontend --typescript
```

Choose:

- App Router: Yes
- Tailwind CSS: Yes
- TypeScript: Yes

### 2. Install Required Packages

```bash
yarn add graphql-request graphql
```

> `graphql-request`: lightweight GraphQL client
> `graphql`: required peer dependency

### 3. Project Folder Structure (inside Next.js folder)

Create a `subgraph` folder to organize query logic.

```
nft-subgraph-frontend/
â”œâ”€â”€ app/
â”‚   â””â”€â”€ page.tsx         # Main page calling subgraph
â”œâ”€â”€ subgraph/
â”‚   â”œâ”€â”€ client.ts        # GraphQL client
â”‚   â”œâ”€â”€ index.ts         # Central export
â”‚   â”œâ”€â”€ types.ts         # NFT interface
â”‚   â””â”€â”€ queries/
â”‚       â””â”€â”€ getNFTs.ts   # Subgraph query
```

### 4. Create GraphQL Client

Inside `nft-subgraph-frontend/subgraph/client.ts`:

```typescript
import { GraphQLClient } from 'graphql-request';

const SUBGRAPH_URL = '<YOUR SUBGRAPH URL>';

// Initialize a GraphQL client pointing to your subgraph endpoint
const graphClient = new GraphQLClient(SUBGRAPH_URL);

export default graphClient;
```

You can find your Subgraph URL in the studio here:
![Endpoint URL](/readme-images/subgraph-endpoint-url.png)

### 5. Create Type Definition

Inside `nft-subgraph-frontend/subgraph/types.ts`:

```typescript
// Defines the shape of NFT data returned by the subgraph
export interface NFT {
  id: string;
  tokenId: number;
  owner: string;
  contract: string;
}
```

This interface helps enforce type safety in your query and component logic.

### 6. NFT Query Logic

Inside `nft-subgraph-frontend/subgraph/queries/getNFTs.ts`:

```typescript
import { gql } from 'graphql-request';
import graphClient from '../client';
import { NFT } from '../types';

// GraphQL query to fetch a list of NFT entities
const GET_NFTS_QUERY = gql`
  query GetNFTs($first: Int!, $skip: Int!) {
    nfts(first: $first, skip: $skip) {
      id
      tokenId
      owner
      contract
    }
  }
`;

// Interface for expected response from query
interface NFTSearchResults {
  nfts: NFT[];
}

// Function to execute the query and return an array of NFTs
export async function getNFTs(
  first: number = 10,
  skip: number = 0
): Promise<NFT[]> {
  const data: NFTSearchResults = await graphClient.request(GET_NFTS_QUERY, {
    first,
    skip,
  });
  return data.nfts;
}
```

This function lets you reuse `getNFTs()` anywhere in your frontend to fetch NFTs indexed by your subgraph.

### 7. Export All Functions with Helper

Inside `nft-subgraph-frontend/subgraph/index.ts`:

```typescript
export * from './queries/getNFTs';
```

Instead of importing each query manually, you can now do:

```typescript
import { getNFTs } from '@/subgraph';
```

### 8. Render NFTs on Frontend

Inside `nft-subgraph-frontend/app/page.tsx`:

```tsx
import { getNFTs } from '@/subgraph';

export default async function Home() {
  const nfts = await getNFTs(10); // Fetch first 10 NFTs

  return (
    <main className='p-8'>
      <h1 className='text-xl font-bold mb-4'>NFT List</h1>
      <ul className='space-y-2'>
        {nfts.map((nft) => (
          <li key={nft.id}>
            <p>
              <strong>ID:</strong> {nft.id}
            </p>
            <p>
              <strong>Token ID:</strong> {nft.tokenId}
            </p>
            <p>
              <strong>Owner:</strong> {nft.owner}
            </p>
            <p>
              <strong>Contract:</strong> {nft.contract}
            </p>
          </li>
        ))}
      </ul>
    </main>
  );
}
```

This is a simple SSR page that fetches and renders NFT data using the subgraph.

### 9. Run the App

```bash
yarn dev
```

Visit http://localhost:3000 in your browser. You should now see a list of NFTs pulled directly from your subgraph.
